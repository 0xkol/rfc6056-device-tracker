# Copyright (c) 2022 Moshe Kol, Amit Klein and Yossi Gilad
# Available under MIT License

import socket
import threading
import time
import struct
import random
import sys
import argparse
import logging as log

log.basicConfig(format="%(asctime)s %(message)s", level=log.INFO)

IP_LOCAL_PORT_RANGE_PATH = "/proc/sys/net/ipv4/ip_local_port_range"
LOOPBACK_IPV4 = '127.1.2.3'
SERVER_LISTENING_PORT = 12345
NR_ALG4_DETECTION_MEASUREMENTS = 210
MONITOR_INTERVAL_SEC = 21
ALG3_NR_CONNECTIONS = 50
ALG3_NR_ATTEMPTS = 4
NR_SANITY_MEASUREMENTS = 10

stop_server_event = threading.Event()


def server(port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((LOOPBACK_IPV4, port))
        s.listen(5)
        while True:
            if stop_server_event.is_set():
                return
            cs, addr = s.accept()
            cs.send(struct.pack('>H', addr[1]))
            cs.close()


def get_source_port(port, ignore_response=False):
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((LOOPBACK_IPV4, port))
            if ignore_response:
                return 0
            s.setblocking(False)
            s.settimeout(2)
            sport = struct.unpack('>H', s.recv(2))[0]
            return sport
    except ConnectionRefusedError:
        if ignore_response:
            pass
    return 0


def source_port_diff(s0, s1):
    return (s1 - s0) % (args.port_range_hi - args.port_range_lo + 1)


def __is_algorithm_3(args, nconns):
    s0 = get_source_port(args.server_port)
    for _ in range(nconns):
        p = random.randint(SERVER_LISTENING_PORT + 16, SERVER_LISTENING_PORT + 16 + 256)
        get_source_port(p, ignore_response=True)
    s1 = get_source_port(args.server_port)
    diff = source_port_diff(s0, s1)
    log.info("\t%d %d (diff: %d)" % (s0, s1, diff))
    if diff >= nconns * 2:
        return True
    return False


def is_algorithm_3(args):
    return all(__is_algorithm_3(args, ALG3_NR_CONNECTIONS) for _ in range(ALG3_NR_ATTEMPTS))


def detect_tcp_source_port_selection_algorithm(args):
    log.info("Detecting RFC 6056 Algorithm 3...")
    if is_algorithm_3(args):
        return "RFC 6056 Algorithm 3 (Not Vulnerable)"

    log.info("Detecting RFC 6056 Algorithm 4...")
    log.info("Monitoring source port measurements for %ds..." % MONITOR_INTERVAL_SEC)
    s0 = get_source_port(args.server_port)
    for _ in range(NR_ALG4_DETECTION_MEASUREMENTS):
        s1 = get_source_port(args.server_port)
        diff = source_port_diff(s0, s1)
        log.info("\t%d %d (diff: %d)" % (s0, s1, diff))
        # In the DHPS patch, a value between 1 to 8 (times 2) is always added to the table cell
        # so check the re-seeding point by looking for a difference larger than 8*2=16.
        # Use 100 here to account for some sporadic noise in the system.
        if diff >= 100:
            return "RFC 6056 Algorithm 4 (Not Vulnerable)"
        s0 = s1
        time.sleep(MONITOR_INTERVAL_SEC/NR_ALG4_DETECTION_MEASUREMENTS)
    return "RFC 6056 Algorithm 4 (Vulnerable)"


def sanity_test(args):
    """ Linux machines will emit even source ports """
    log.info("Performing a sanity test...")
    for _ in range(NR_SANITY_MEASUREMENTS):
        s = get_source_port(args.server_port)
        if s % 2 != 0:
            return False
    log.info("\tPass.")
    return True


def main(args):
    server_thread = threading.Thread(target=server, args=(args.server_port,))
    server_thread.start()
    time.sleep(0.2)  # Wait for server to start

    if sanity_test(args):
        verdict = detect_tcp_source_port_selection_algorithm(args)
        log.info("Verdict: %s" % verdict)
    else:
        log.info("Is this a Linux machine?")

    stop_server_event.set()
    get_source_port(args.server_port)
    server_thread.join()


def detect_ip_local_port_range(args):
    log.info("Auto detect the IP local port range...")
    try:
        with open(IP_LOCAL_PORT_RANGE_PATH, "r") as f:
            data = f.read()
            data = data.split()
            lo, hi = int(data[0]), int(data[1])
            args.port_range_lo = lo
            args.port_range_hi = hi
            log.info("IP local port range detected: [%d, %d]" % (lo, hi))
    except:
        log.error("IP local port range could not be automatically detected. \
                   Please use \"--lo\" and \"--hi\" to specify these values manually.")
        sys.exit(1)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.description = """
    This tool detects whether the tested Linux machine is vulnerable 
    to CVE-2022-32296 (Linux device tracking based on Algorithm 4 of RFC 6056).

    The tool output is which RFC 6056 port selection algorithm 
    is used by the tested Linux machine. The options are:
    (a) RFC 6056 Algorithm 3 (Not Vulnerable), or
    (b) RFC 6056 Algorithm 4 (Vulnerable), or
    (c) RFC 6056 Algorithm 4 (Not Vulnerable).

    For more information: https://github.com/0xkol/rfc6056-device-tracker
    """
    parser.add_argument('-P', dest='server_port', required=False, type=int, default=SERVER_LISTENING_PORT,
                        help="Listening port for the server (on address %s)" % LOOPBACK_IPV4)
    parser.add_argument('--lo', dest='port_range_lo', required=False, type=int,
                        help="Lowest port in the IP local port range")
    parser.add_argument('--hi', dest='port_range_hi', required=False, type=int,
                        help="Highest port in the IP local port range")
    args = parser.parse_args()

    print("=================================")
    print("      CVE-2022-32296 Tester      ")
    print("=================================")
    print("For more information: https://github.com/0xkol/rfc6056-device-tracker")
    print()

    if args.port_range_lo is None or args.port_range_hi is None:
        detect_ip_local_port_range(args)
    main(args)
